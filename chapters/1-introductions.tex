\chapter{Introduction}
\ \\
Nowadays, technology has permeated every aspect of the human life, allowing everything and everyone to be interconnected anywhere and at any moment. Thanks to its importance, it quickly became one of the most popular field of work in the modern age, with organizations employing and relying completely on such technologies to provide their services. However, cyber-crime became very common. 

The Cybersecurity is an aspect of informatics whose role is ensuring the safety of the technologies available and the people who use them, both in terms of software and infrastructure, protecting systems against security issues and vulnerabilities that could potentially be exploited by malicious entities. In fact, according to the "Consortium for IT Software Quality" (CISQ), poorly designed software cost the economy $\$2.08$ trillion dollars in 2020 alone \cite{forbes}, numbers that show how security against software bugs and vulnerabilities should be handled with maximum attention.

In this context, \textit{software security} aims to analyze and detect bugs in a program that may pose a security threat to any user and/or organization employing said software. The "National Vulnerability Database" (NVD) classified software vulnerabilities in 5 root causes \cite{nist}: input validation, access control, exceptions handling, configuration errors and race condition. All these scenarios may lead to a criminal gaining access to your system and execute malicious code, potentially also with the intention of performing privilege escalation and take ownership of the machine. 

One of the 7 components in the "Software Development Life Cycle" (SDLC) is \textit{Testing}, which means analyzing and checking your code to make sure that it satisfies some quality, correctness and security criteria both in terms of functionalities provided and underlying infrastructure. This also provides crucial information that can be used to further improve the development of the product.  

This may either be done "statically", focusing on prevention and removal of potential defects from source code by means of coding standards and best practices, or "dynamically", analyzing the code during its execution with different inputs.





\section{Context}
One of the most important goals of software testing is \textit{finding bugs}, defects in the code causing unwanted and unexpected results, that hinder the security of the product and may lead to vulnerabilities being exploited by malicious people. In this context, a popular technique is \textit{automated testing}, which is based on using a tool to control the execution flow of the software being tested and analyze its results via repetitive tasks performed over long periods of time. 

An example of this approach is \textit{fuzzing}, a very old technique invented in 1988 primarily used to automate simple tests previously performed by humans, that gained popularity due to its ability to discover crashes and bugs. Its base idea revolves around feeding (seemingly) random inputs to a program, analyze its execution flow and generate new testcases with the intention of exploring all possible paths in the code as well as trigger unexpected behavior. This process is repeated across several and extensive fuzzing sessions, while its effectiveness and simplicity of use allowed developers from all languages and level of knowledge to improve the security of their software. It also discovered one of the most famous and critical bugs in history, the "Heartbleed" bug that affected OpenSSL.

Since 2001, with the rise of "Open-Source Software", ensuring the security of software that was freely available and modifiable by anyone became a top priority: because the source code was freely accessible, it was only a matter of time before cyber-criminals began exploiting their vulnerabilities. Moreover, many modern paid applications often rely on such free software to provide their services. 

\matteo{Be careful not dividing paragraph if not needed. A paragraph is a set of sentences that are related to the same topic, and should not be split with "newlines". The next 4 paragraphs are all related to the same exact topic and should be merged. You make this mistake all throughout the thesis, try to fix it. }

Given their popularity, Google announced the ClusterFuzz project in 2012, a cloud-based fuzzing infrastructure to test security-critical components of the Chromium web browser, where fuzzer developers could upload their own fuzz tool and collect bug-bounties if their product discovered a crash in the browser.

In 2016, this infrastructure was extended in a new campaign called OSS-Fuzz, allowing open-source developers to integrate their product in this ecosystem while Google provided its own infrastructure to perform continuous fuzzing of such projects.

Later, in 2021, Google announced yet a new project called FuzzBench, focused on helping the development of open-source fuzzers thanks to tests based on real-world benchmarks and daily reports.

These frameworks use a common sharing infrastructure that is Google Cloud, allowing them to easily exchange and access data independently.

All these automated fuzz-testing infrastructures are also valuable to researchers to analyze and understand the development of open-source projects, access the corpora used by their developers and perform fuzzing locally for both educational and research purposes. 



\matteo{You are missing a paragraph about our problem; continuous (automated) fuzzing works very well, but it is important to check that it is not missing any bug. That's what we are doing in this thesis (you can do it both in 1.1 or in 1.2)}

\section{Thesis Idea and Contributions}
This thesis revolved around analyzing the workflow and results produced by automated testing infrastructures, more specifically the OSS-Fuzz and FuzzBench campaigns. This is because although these infrastructures have enormous computing capabilities and have been providing continuous fuzzing for several years, they still suffer from machine errors and limitations due to their design's choices.

This work will show that the evaluated fuzzing frameworks are indeed missing a relevant amount of bugs and vulnerabilities, that were then promptly reported to the respective developers hoping that this would help them make their software more secure. 

\matteo{This list is not final, I'll check it later}

\paragraph{Contributions}
To summarize, this thesis makes the following contributions:
\begin{itemize}
    \item A study of the accuracy of existing continuous fuzzing frameworks.
    \item An assessment of the relevance of software sanitizers in fuzzing campaigns.
    \item An enhancement for the design of more accurate continuous fuzzing frameworks.
\end{itemize}



\section{Outline}

\matteo{Same story about paragraphs here, this should all be contained in one paragraph.}

Chapter \ref{chap_2} provides all the necessary concepts to understand what is fuzzing and how a fuzzer works, along with notions about some tools that are widely used in this field. It also introduces the definition of "Open-Source Program" and the automated testing infrastructures analyzed in this work.

Chapter \ref{chap_3} discusses the methodology applied during the selection of the projects and the test phase, including the problems faced during these process and the solutions found.

Chapter \ref{chap_4} shows the results obtained, analyzing their importance, as well as discussing the reports issued and the developers' responses.

Chapter \ref{chap_5} presents some final considerations about fuzzing, how it's perceived in the current era and provides some insights and suggestions on how to improve the current infrastructure.
\ziosaba{Chapter 5 outline to revise later}