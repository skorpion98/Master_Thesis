\chapter{Conclusions and Future Work} \label{chap_5}
\ \\

In this last chapter, we will summarize the work presented in this thesis. After that, we will present some directions for future work that could be explored to further improve our solution and the impact it can have in malware analysis research.

\section{Conclusion}
This work first introduced the concepts of fuzzing and sanitizers, a popular bug-detection approach in testing environments that has proven to be particularly effective, especially when combined with the "Continuous-Fuzzing/Continuous-Integration" pipeline that many modern organizations employ when developing their products. Then, we introduced autonomous fuzzing frameworks, how they work and described the chosen frameworks analyzed. Followed a description of the methodology used to analyze said frameworks along with how bugs were collected, analyzed and reported. Concludes a thorough analysis of the results, discussing how developers perceived the bug reports created and the implications of the behaviors observed with some case studies.

This study highlighted the popularity of autonomous fuzzing infrastructures and their effectiveness, but also that the lack of standardized approaches and design trade-offs are major contributors to their accuracy when it comes to automatically detecting and reporting bugs. Although the overall number of projects analyzed is not representative of the entire campaigns, the applied methodology still managed to discover several hundreds of previously unreported bugs, showing that the workflow adopted by the analyzed campaigns presents flaws that lead to overlooked bugs and potential vulnerabilities.

In today's world, where software development techniques are constantly changing and improving, it is crucial to ensure that all aspects of software development progress at the same pace, including the "Testing" phase: many organizations rely on automated testing, a time-efficient and effective solution, but that comes with its shortcomings as highlighted by this work. Therefore, while relying on autonomous testing techniques and infrastructures has proven its efficacy in time, developers should monitor, configure and employ these tools regularly and keep them up to date to ensure that also the testing environments can be as accurate and productive as possible.


\newpage
\section{Future Work}
The results shown by this work highlighted how using different combinations of fuzzing engines and sanitizers produced new and previously unseen bugs, which if properly fixed ultimately lead to a more refined and stable product, meeting the objective of many modern organizations. However, it is also important to notice that most autonomous fuzzing frameworks have limitations due to design choices and resources trade-offs, which have been considered acceptable after rigorous accuracy and effectiveness analyses. Therefore, applying a single solution to all of them would be suboptimal. Nonetheless, keeping the most inner workings not easily accessible or private will obviously limit the developers' understanding of such infrastructures, making them unable to provide insightful help or suggestions towards their improvements. 

\matteo{Expand this work to other fuzzing frameworks? We found some issues that are general (e.g. use as many sanitizers as possible), but also issues that are specific to the frameworks we tested: other frameworks might have different issues specific to them}
\ziosaba{Tutti i framework analizzati hanno dei limiti, però è anche vero che (come ho provato ad abozzare sopra) c'è un problema relativo al fatto che se faccio un certo tipo di fuzzing non posso farne un altro, o anche che ci sono del limiti relativi all'utilizzo di risorse che a casisitche in cui si possono perdere dei bug. Mi verrebbe in mente di scrivere una cosa del tipo "questi framework dovrebbero fornire delle linee guida generali per consentire agli sviluppatori di massimizzare i tool e le funzionalità fornite", o qualcosa del genere}



Overall, fuzzing is a technique with no general guidelines: each developer tests their programs as they see fit, using general common sense but also following potentially wrong beliefs, and this oftentimes lead to missing bugs in the process. 

\matteo{Provide general guidelines for fuzzing frameworks. Right now there is none, users just adhere to common sense; we could study and propose guidelines that prevent the issues we witnessed.}
\ziosaba{Anche qui: fare fuzzing richiede conoscenze, skill e (potenzialmente) ricompilare cose che non si possono ricompilare (MSan con le librerie) e quindi c'è una limitazione relativa alla versatilità dei tool, ma non so se ha senso come "lavoro futuro". Oltretutto, tornando al discorso di prima, ci sarebbe da fare delle guideline del tipo "testa tutto con tutto",ma se non hai le conoscenze e le skill per compilare i progetti in tanti modi diversi e secondo le richieste di un tool specifico dovresti creare delle guide speciifche che ti spiegano tutto per filo e per segno, bho non mi convince molto.}

\matteo{can we think of something else? maybe something related to sanitizers}